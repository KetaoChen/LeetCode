// OJ: https://leetcode.com/problems/minimize-malware-spread/
// Author: https://leetcode.com/charlesna/
// Time: O(n^2)
// Space: O(n)
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // find the number of malware of each scc. 
        int l = graph.length;
        int[] parent = new int[l];
        int[] count = new int[l];
        for (int i = 0; i < l; i++) {
            parent[i] = i;
            count[i] = 1;
        }
        for (int i = 0; i < l; i++) {
            for (int j = i + 1; j < l; j++) {
                if (graph[i][j] == 1) {
                    int px = find(parent, i);
                    int py = find(parent, j);
                    if(px != py) {
                        parent[px] = py;
                        count[py] += count[px];
                    }
                }
            }
        }
        int[] ini = new int[l];
        for (int i : initial) {
            ini[find(parent, i)]++;
        }
        Arrays.sort(initial);
        int res = initial[0], max = 0;
        for (int i : initial) {
            int p = find(parent, i);
            if (ini[p] == 1 && count[p] > max) {
                max = count[p];
                res = i;
            }
        }
        return res;
    }
    private int find(int[] p, int x) {
        if (p[x] == x) {
            return x;
        }
        p[x] = find(p, p[x]);
        return p[x];
    }
}