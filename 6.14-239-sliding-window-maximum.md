---
tags:
  - leetcode
  - heap
  - sliding window
created: '2019/6/14 下午11:04:56'
difficulty: hard
---

# 0239-sliding-window-maximum

## Problem

Given an array _nums_, there is a sliding window of size _k_ which is moving from the very left of the array to the very right. You can only see the _k_ numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.  
  


**Example:**  
  


```text
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Note:**  
  
You may assume _k_ is always valid, 1 ≤ k ≤ input array's size for non-empty array.  
  


**Follow up:**  
  
Could you solve it in linear time?

## Solution

java

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        //this is a monotonous queue in descending order
        if (nums.length == 0) {
            return new int[]{};
        }
        Deque<Integer> dq = new ArrayDeque<>();
        int[] res = new int[nums.length - k + 1];
        int resIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            //if the item is out the window poll
            while (!dq.isEmpty() && dq.peek() < i - k + 1) {
                dq.poll();
            }
            //if this item is larger than the item before it, poll that out
            while (!dq.isEmpty() && nums[i] > nums[dq.peekLast()]) {
                dq.pollLast();
            }

            //put this potential maximum in the dq
            dq.offer(i);
            if (i >= k - 1) {
                res[resIndex++] = nums[dq.peek()];
            }
        }
        return res;
    }
}
​
```

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0) {
            return new int[]{};
        }
        TreeMap<Integer, Integer> map = new TreeMap<>();
        int i = 0;
        while (i < k) {
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
            i++;
        }
        int j = 0; 
        int[] res = new int[nums.length - k + 1];
        res[0] = map.lastKey();
        while (i < nums.length) {
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
            if (map.get(nums[j]) == 1) {
                map.remove(nums[j]);
            }
            else {
                map.put(nums[j], map.get(nums[j]) - 1);
            }
            i++;
            j++;
            res[j] = map.lastKey();
        }
        return res;
    }
}
​
```

