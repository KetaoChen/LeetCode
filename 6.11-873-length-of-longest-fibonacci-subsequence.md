---
tags:
  - leetcode
  - array
  - dynamic programming
created: '2019/6/14 下午11:07:35'
difficulty: medium
---

# 0873-length-of-longest-fibonacci-subsequence

## Problem

A sequence `X_1, X_2, ..., X_n` is _fibonacci-like_ if:  
  


* * `n >= 3`
* * `X_i + X_{i+1} = X_{i+2}` for all `i + 2 <= n`
* 
Given a **strictly increasing** array `A` of positive integers forming a sequence, find the **length** of the longest fibonacci-like subsequence of `A`.  If one does not exist, return 0.  
  


\(_Recall that a subsequence is derived from another sequence `A` by deleting any number of elements \(including none\) from `A`, without changing the order of the remaining elements.  For example, `[3, 5, 8]` is a subsequence of `[3, 4, 5, 6, 7, 8]`._\)  
  


* 
**Example 1:**  
  


```text
Input: [1,2,3,4,5,6,7,8]
Output: 5
Explanation:
The longest subsequence that is fibonacci-like: [1,2,3,5,8].
```

**Example 2:**  
  


```text
Input: [1,3,7,11,12,14,18]
Output: 3
Explanation:
The longest subsequence that is fibonacci-like:
[1,11,12], [3,11,14] or [7,11,18].
```

**Note:**  
  


* * `3 <= A.length <= 1000`
* * `1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9`
* * _\(The time limit has been reduced by 50% for submissions in Java, C, and C++.\)_
* 
## Solution

java

```java
class Solution {
    public int lenLongestFibSubseq(int[] A) {
        //brute force, for every two number, find the longest subsequence.
        int res = 0;
        int l = A.length;
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < l; i++) {
            set.add(A[i]);
        }
        for (int i = l - 1; i > 0; i--) {
            for (int j = i - 1; j >= 0; j--) {
                int large = A[i];
                int small = A[j];
                int cur = 2;
                while (large - small < small) {
                    int next = large - small;
                    if (!set.contains(next)) {
                        break;
                    }
                    large = small;
                    small = next;
                    cur++;
                }
                if (cur >= 3 && cur > res) {
                    res = cur;
                }
            }
            //System.out.print(res + " ");
        }
        return res;
    }

    private int findIndex(int[] A, int target, int end) {
        int start = 0;
        while (start + 1 < end) {
            int mid = (end - start) / 2 + start;
            if (A[mid] == target) {
                return mid;
            }
            if (A[mid] > target) {
                end = mid;
            }
            else {
                start = mid;
            }
        }
        if (A[start] == target) {
            return start;
        }
        if (A[end] == target) {
            return end;
        }
        return -1;
    }
}
​
```

