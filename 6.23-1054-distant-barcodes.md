---
tags:
  - leetcode
  - heap
  - sort
created: '2019/6/23 下午9:41:55'
difficulty: medium
---

# 1054-distant-barcodes

## Problem

In a warehouse, there is a row of barcodes, where the `i`-th barcode is `barcodes[i]`.  
  


Rearrange the barcodes so that no two adjacent barcodes are equal.  You may return any answer, and it is guaranteed an answer exists.  
  


**Example 1:**  
  


```text
Input: [1,1,1,2,2,2]
Output: [2,1,2,1,2,1]
```

**Example 2:**  
  


```text
Input: [1,1,1,1,2,2,3,3]
Output: [1,3,1,3,2,1,2,1]
```

**Note:**  
  


1. 2. `1 <= barcodes.length <= 10000`
3. 4. `1 <= barcodes[i] <= 10000`
5. 
## Solution

java

```java
class Solution {
    public int[] rearrangeBarcodes(int[] barcodes) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i : barcodes) {
            map.put(i, map.getOrDefault(i, 0) + 1);
        }
        PriorityQueue<Integer> pq = new PriorityQueue<>(10, new Comparator<Integer>() {
            @Override
            public int compare(Integer i1, Integer i2) {
                return map.get(i2) - map.get(i1);
            }
        });

        for (int i : map.keySet()) {
            pq.offer(i);
        }
        int[] res = new int[barcodes.length];
        int index = 0;
        while (index < barcodes.length) {
            int cur = pq.poll();
            if (index == 0 || cur != res[index - 1]) {
                res[index] = cur;
            }
            else if (cur == res[index - 1] && !pq.isEmpty()) {
                int next = pq.poll();
                res[index] = next;
                pq.offer(cur);
                cur = next;
            }
            map.put(cur, map.get(cur) - 1);
            if (map.get(cur) != 0) {
                pq.offer(cur);
            }
            index++;
        }
        return res;
    }
}
​
```

