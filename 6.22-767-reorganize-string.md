---
tags:
  - leetcode
  - string
  - heap
  - greedy
  - sort
created: '2019/6/22 下午5:54:19'
difficulty: medium
---

# 0767-reorganize-string

## Problem

Given a string `S`, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.  
  


If possible, output any possible result.  If not possible, return the empty string.  
  


**Example 1:**  
  


```text
Input: S = "aab"
Output: "aba"
```

**Example 2:**  
  


```text
Input: S = "aaab"
Output: ""
```

**Note:**  
  


* * `S` will consist of lowercase letters and have length in range `[1, 500]`.
* 
## Solution

java

```java
class Solution {
    public String reorganizeString(String S) {
        //count the number of each character
        //if the character that has highest number is more than half of the length of the string + 1, return ""
        //use a priorityqueue to build the rearrange  string

        int l = S.length();
        if (l == 0) {
            return "";
        }

        HashMap<Character, Integer> map = new HashMap<>();
        for (char c : S.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        PriorityQueue<Character> pq = new PriorityQueue<>(new Comparator<Character>() {
            @Override
            public int compare(Character i, Character j) {
                return map.get(j) - map.get(i);
            }
        });
        for (char c : map.keySet()) {
            if (map.get(c) > l / 2 + 1) {
                return "";
            }
            pq.offer(c);
        }

        StringBuilder sb = new StringBuilder();
        while(!pq.isEmpty()) {
            char cur = pq.poll();
            if (sb.length() == 0 || cur != sb.charAt(sb.length() - 1)) {
                sb.append(cur);
            }
            else {
                if (pq.isEmpty()) {
                    return "";
                }
                char next = pq.poll();
                sb.append(next);
                pq.offer(cur);
                cur = next;
            }
            map.put(cur, map.get(cur) - 1);
            if (map.get(cur) > 0) {
                pq.offer(cur);
            }
        }
        return sb.toString();
    }
}
​
```

